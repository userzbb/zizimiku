# C++引用语法详解

## 📖 什么是引用？

引用（Reference）是C++中的一个重要特性，它为已存在的变量提供一个**别名**。引用不是一个新的对象，而是给现有对象起的另一个名字。

## 🔧 基本语法

### 声明语法
```cpp
数据类型& 引用名 = 被引用的变量;
```

### 示例
```cpp
int x = 10;
int& ref = x;  // ref是x的引用（别名）
```

## 📋 引用的核心特性

### 1. **必须初始化**
```cpp
int& ref;        // ❌ 错误：引用必须初始化
int& ref = x;    // ✅ 正确：引用必须在声明时初始化
```

### 2. **不能重新引用**
```cpp
int x = 10, y = 20;
int& ref = x;    // ref引用x
ref = y;         // ⚠️ 注意：这不是重新引用，而是赋值！
                 // 这会将y的值赋给x，ref仍然引用x
```

### 3. **共享内存地址**
```cpp
int x = 10;
int& ref = x;
cout << &x << endl;    // 地址相同
cout << &ref << endl;  // 地址相同
```

### 4. **不能为空**
```cpp
int* ptr = nullptr;    // ✅ 指针可以为空
int& ref = nullptr;    // ❌ 引用不能为空
```

## 🎯 引用的类型

### 1. **普通引用**
```cpp
int x = 10;
int& ref = x;
ref = 20;        // 可以修改原变量
```

### 2. **常量引用（const引用）**
```cpp
int x = 10;
const int& ref = x;
// ref = 20;     // ❌ 错误：不能修改
cout << ref;     // ✅ 可以读取

// 特殊能力：可以绑定临时对象
const int& temp_ref = 42;         // ✅ 可以引用字面值
const string& str_ref = "Hello";  // ✅ 可以引用临时对象
```

### 3. **数组引用**
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int (&arr_ref)[5] = arr;  // 数组引用，必须指定大小

// ❌ 不能创建引用数组
// int& ref_array[3] = {a, b, c};  // 错误
```

## 🔄 函数中的引用

### 1. **引用作为参数**

#### 修改原变量
```cpp
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int x = 10, y = 20;
swap(x, y);  // x和y的值被交换
```

#### 避免拷贝（提高效率）
```cpp
void process(const string& str) {  // 不拷贝string对象
    cout << str << endl;
}

void process(string str) {         // 会拷贝string对象（效率低）
    cout << str << endl;
}
```

### 2. **引用作为返回值**

#### 允许链式调用
```cpp
class MyClass {
public:
    MyClass& setValue(int val) {
        value = val;
        return *this;  // 返回自身引用
    }
};

MyClass obj;
obj.setValue(10).setValue(20);  // 链式调用
```

#### ⚠️ 危险：返回局部变量的引用
```cpp
int& dangerous() {
    int local = 42;
    return local;  // ❌ 危险！local在函数结束时被销毁
}

int& safe() {
    static int static_var = 42;
    return static_var;  // ✅ 安全：静态变量生命周期长
}
```

## 🆚 引用 vs 指针对比

| 特性 | 引用 | 指针 |
|------|------|------|
| **初始化** | 必须初始化 | 可以不初始化 |
| **重新指向** | 不能重新引用 | 可以重新指向 |
| **空值** | 不能为空 | 可以为nullptr |
| **语法** | 直接使用 | 需要解引用(*) |
| **算术运算** | 不支持 | 支持(++, --, +, -) |
| **内存占用** | 无额外开销 | 需要存储地址 |

### 示例对比
```cpp
int x = 10;

// 指针方式
int* ptr = &x;
*ptr = 20;        // 需要解引用
ptr = nullptr;    // 可以为空
ptr++;            // 可以算术运算

// 引用方式
int& ref = x;
ref = 20;         // 直接使用
// ref = nullptr; // ❌ 不能为空
// ref++;         // ❌ 不能算术运算
```

## 🎯 最佳实践

### 1. **优先使用const引用传参**
```cpp
// ✅ 好：避免拷贝，明确只读意图
void print(const vector<int>& data) {
    for (const auto& item : data) {
        cout << item << " ";
    }
}

// ❌ 差：会拷贝整个vector
void print(vector<int> data) {
    for (const auto& item : data) {
        cout << item << " ";
    }
}
```

### 2. **范围for循环使用引用**
```cpp
vector<string> strings = {"hello", "world"};

// ✅ 只读遍历：避免拷贝
for (const auto& str : strings) {
    cout << str << " ";
}

// ✅ 修改遍历
for (auto& str : strings) {
    str += "!";
}
```

### 3. **返回引用支持链式调用**
```cpp
class Builder {
public:
    Builder& setName(const string& name) {
        this->name = name;
        return *this;
    }
    
    Builder& setAge(int age) {
        this->age = age;
        return *this;
    }
};

Builder builder;
builder.setName("Alice").setAge(25);  // 链式调用
```

## ⚠️ 常见陷阱

### 1. **悬空引用**
```cpp
int& getBadReference() {
    int local = 42;
    return local;  // ❌ 返回局部变量引用
}
```

### 2. **误解引用重新绑定**
```cpp
int x = 10, y = 20;
int& ref = x;
ref = y;  // ⚠️ 这不是重新引用，而是赋值！
```

### 3. **临时对象引用**
```cpp
string& bad = string("temp");      // ❌ 不能引用临时对象
const string& good = string("temp"); // ✅ const引用可以
```

## 🚀 现代C++特性

### C++11: 右值引用
```cpp
string&& rvalue_ref = string("temp");  // 右值引用
```

### C++17: 结构化绑定
```cpp
map<string, int> m = {{"Alice", 25}};
for (const auto& [name, age] : m) {    // 结构化绑定
    cout << name << ": " << age << endl;
}
```

### 引用包装器
```cpp
#include <functional>
vector<reference_wrapper<int>> refs;
int a = 1, b = 2;
refs.push_back(ref(a));  // 包装引用存入容器
refs.push_back(ref(b));
```

## 📝 总结

引用是C++中强大且高效的特性：

- **本质**：为现有变量提供别名
- **优势**：语法简洁、无额外开销、类型安全
- **用途**：函数参数传递、返回值、避免拷贝
- **注意**：必须初始化、不能重新绑定、避免悬空引用

掌握引用的正确使用方法，可以让你的C++代码更加高效和优雅！