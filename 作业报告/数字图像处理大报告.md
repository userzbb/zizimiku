# 数字图像处理大报告

**学生姓名：** 张忠波  
**学号：** 202331223125  
**班级：** 通信2301  
**提交日期：** 2025年9月23日

---

## 摘要

本报告实现了5个常用的数字图像处理算法，包括图像几何变换、直方图处理、频域变换、图像去噪以及边缘检测和锐化。通过MATLAB编程实现了这些算法的核心功能，并对处理结果进行了详细分析和说明。实验结果表明，所实现的算法能够有效处理数字图像，达到预期的处理效果。

**关键词：** 数字图像处理，图像变换，直方图均衡，傅里叶变换，图像去噪，边缘检测

---

## 目录

1. [图像几何变换算法](#1-图像几何变换算法)
2. [直方图均衡和规定化算法](#2-直方图均衡和规定化算法)  
3. [二维离散傅里叶变换算法](#3-二维离散傅里叶变换算法)
4. [数字图像去噪算法](#4-数字图像去噪算法)
5. [图像边缘检测和锐化算法](#5-图像边缘检测和锐化算法)
6. [总结](#总结)

---

## 1. 图像几何变换算法

### 1.1 算法原理

图像几何变换是数字图像处理中的基础操作，主要包括：

- **图像缩放：** 改变图像的尺寸大小
- **图像旋转：** 按指定角度旋转图像
- **图像平移：** 将图像在坐标系中移动

### 1.2 实现方法

本实验采用MATLAB内置函数实现几何变换：

- `imresize()`: 图像缩放，支持双线性、双三次、最近邻插值
- `imrotate()`: 图像旋转，可选择保留全部内容或裁剪
- `imtranslate()`: 图像平移

### 1.3 源程序代码

```matlab
%% 1. 读取图像
% 使用MATLAB自带图像
original = imread('1.bmp');
figure('Name', '图像处理演示', 'Position', [100 100 1000 800]);
subplot(3,3,1); imshow(original); title('1. 原始图像');

%% 2. 图像缩放 (imresize)
% 缩小到0.7倍
scaled_1 = imresize(original,10, 'bilinear');
% 放大到1.4倍
scaled_2 = imresize(original, 10, 'bicubic');
scaled_3 = imresize(original, 10, 'nearest');
subplot(3,3,2); imshow(scaled_1); title('2.bilinear ');
subplot(3,3,3); imshow(scaled_2); title('3. bicubic');
subplot(3,3,3); imshow(scaled_3); title('4. nearest');

%% 3. 图像旋转 (imrotate)
% 旋转45度，保留全部内容
rotated_45 = imrotate(original, 45, 'bilinear', 'loose');
% 旋转-90度，裁剪为原尺寸
rotated_neg90 = imrotate(original, -90, 'nearest', 'crop');
subplot(3,3,4); imshow(rotated_45); title('5. 旋转45度');
subplot(3,3,5); imshow(rotated_neg90); title('6. 旋转-90度');

%% 4. 图像平移 (imtranslate)
% 向左上方平移
translated1 = imtranslate(original, [-40, -20]);
% 向右下方平移
translated2 = imtranslate(original, [30, 50]);
subplot(3,3,6); imshow(translated1); title('7. 左上平移');
subplot(3,3,7); imshow(translated2); title('8. 右下平移');
```

### 1.4 结果分析

几何变换算法的实验结果显示：

1. **缩放效果：**
   - 双线性插值能够在放大时保持较好的图像质量
   - 双三次插值在边缘细节保持方面表现更佳
   - 最近邻插值速度快但会产生锯齿效应

2. **旋转效果：**
   - 45度旋转保留了完整的图像信息但增加了画布尺寸
   - -90度旋转通过裁剪保持原尺寸但可能丢失部分信息

3. **平移效果：**
   - 平移操作简单有效，空白区域用黑色填充
   - 可实现图像在任意方向的位移

---

## 2. 直方图均衡和规定化算法

### 2.1 算法原理

**直方图均衡化：** 通过重新分布图像的灰度级，使图像的直方图趋于均匀分布，从而增强图像对比度。

**直方图规定化：** 将原图像的直方图变换为指定的目标直方图分布。

数学表达式：

- 均衡化变换：$s = T(r) = \int_0^r p_r(w)dw$
- 规定化变换：$z = G^{-1}[T(r)]$

### 2.2 实现方法

1. 计算原图像的灰度直方图
2. 求累积分布函数(CDF)
3. 建立变换映射关系
4. 应用变换得到处理后图像

### 2.3 源程序代码

```matlab
%% 直方图均衡函数
function img_eq = histogram_equalization(img)
    [M, N] = size(img);
    
    % 计算直方图
    hist_count = zeros(1, 256);
    for i = 1:M
        for j = 1:N
            gray_level = round(img(i, j)) + 1;
            hist_count(gray_level) = hist_count(gray_level) + 1;
        end
    end
    
    % 计算概率密度函数
    pdf = hist_count / (M * N);
    
    % 计算累积分布函数
    cdf = cumsum(pdf);
    
    % 均衡化变换
    img_eq = zeros(M, N);
    for i = 1:M
        for j = 1:N
            old_gray = round(img(i, j)) + 1;
            img_eq(i, j) = round(cdf(old_gray) * 255);
        end
    end
end

%% 直方图规定化函数
function img_matched = histogram_matching(img, target_hist)
    [M, N] = size(img);
    
    % 对原图像进行直方图均衡
    img_eq = histogram_equalization(img);
    
    % 计算目标直方图的累积分布函数
    target_cdf = cumsum(target_hist);
    
    % 建立映射关系
    mapping = zeros(1, 256);
    for i = 1:256
        eq_value = (i - 1) / 255; % 均衡后的归一化值
        
        % 找到目标CDF中最接近的值
        [~, idx] = min(abs(target_cdf - eq_value));
        mapping(i) = idx - 1;
    end
    
    % 应用映射
    img_matched = zeros(M, N);
    for i = 1:M
        for j = 1:N
            eq_gray = round(img_eq(i, j)) + 1;
            img_matched(i, j) = mapping(eq_gray);
        end
    end
end

%% 创建目标直方图函数
function target_hist = create_target_histogram()
    % 创建高斯分布作为目标直方图
    x = 0:255;
    mu = 128; % 均值
    sigma = 50; % 标准差
    
    target_hist = exp(-(x - mu).^2 / (2 * sigma^2));
    target_hist = target_hist / sum(target_hist); % 归一化
end
```

### 2.4 结果分析

1. **直方图均衡化效果：**
   - 显著提高了图像对比度
   - 使原本集中的灰度分布变得更加均匀
   - 增强了图像的视觉效果

2. **直方图规定化效果：**
   - 成功将原图像的直方图匹配到目标高斯分布
   - 实现了对图像灰度分布的精确控制
   - 在特定应用场景中具有重要价值

---

## 3. 二维离散傅里叶变换算法

### 3.1 算法原理

二维离散傅里叶变换(2D DFT)将空间域图像变换到频域，用于频域分析和滤波。

数学表达式：
$$F(u,v) = \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(ux/M+vy/N)}$$

逆变换：
$$f(x,y) = \frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi(ux/M+vy/N)}$$

### 3.2 实现方法

采用直接计算法实现2D DFT，虽然计算复杂度较高，但有助于理解算法原理。

### 3.3 源程序代码

```matlab
%% 二维DFT函数
function F = dft2d(f)
    [M, N] = size(f);
    F = zeros(M, N);
    
    % 计算二维DFT
    for u = 0:M-1
        for v = 0:N-1
            sum_val = 0;
            for x = 0:M-1
                for y = 0:N-1
                    % DFT核函数
                    exponent = -1j * 2 * pi * (u*x/M + v*y/N);
                    sum_val = sum_val + f(x+1, y+1) * exp(exponent);
                end
            end
            F(u+1, v+1) = sum_val;
        end
    end
end

%% 二维IDFT函数
function f = idft2d(F)
    [M, N] = size(F);
    f = zeros(M, N);
    
    % 计算二维IDFT
    for x = 0:M-1
        for y = 0:N-1
            sum_val = 0;
            for u = 0:M-1
                for v = 0:N-1
                    % IDFT核函数
                    exponent = 1j * 2 * pi * (u*x/M + v*y/N);
                    sum_val = sum_val + F(u+1, v+1) * exp(exponent);
                end
            end
            f(x+1, y+1) = sum_val / (M * N);
        end
    end
end
```

### 3.4 结果分析

1. **频谱特征：**
   - 低频分量集中在频谱中心
   - 高频分量对应图像的细节和边缘信息
   - 相位谱包含了图像的结构信息

2. **重构质量：**
   - IDFT重构图像与原图像几乎完全一致
   - 重构均方误差接近于零，验证了算法正确性

3. **计算复杂度：**
   - 直接计算2D DFT的复杂度为O(M²N²)
   - 对于64×64图像，计算时间可接受

---

## 4. 数字图像去噪算法

### 4.1 算法原理

实现了四种经典去噪算法：

1. **均值滤波：** 用邻域平均值替换中心像素值
2. **中值滤波：** 用邻域中值替换中心像素值，对椒盐噪声效果好
3. **高斯滤波：** 基于高斯函数的加权平均滤波
4. **维纳滤波：** 在频域进行最优线性滤波

### 4.2 性能评价指标

使用峰值信噪比(PSNR)评价去噪效果：
$$PSNR = 10\log_{10}\frac{MAX^2}{MSE}$$

### 4.3 源程序代码

```matlab
%% 均值滤波函数
function filtered_img = mean_filter(img, filter_size)
    [M, N] = size(img);
    filtered_img = zeros(M, N);
    pad_size = floor(filter_size / 2);
    
    % 边界填充
    padded_img = padarray(img, [pad_size, pad_size], 'replicate');
    
    for i = 1:M
        for j = 1:N
            % 提取邻域
            neighborhood = padded_img(i:i+filter_size-1, j:j+filter_size-1);
            filtered_img(i, j) = mean(neighborhood(:));
        end
    end
end

%% 中值滤波函数
function filtered_img = median_filter(img, filter_size)
    [M, N] = size(img);
    filtered_img = zeros(M, N);
    pad_size = floor(filter_size / 2);
    
    % 边界填充
    padded_img = padarray(img, [pad_size, pad_size], 'replicate');
    
    for i = 1:M
        for j = 1:N
            % 提取邻域
            neighborhood = padded_img(i:i+filter_size-1, j:j+filter_size-1);
            filtered_img(i, j) = median(neighborhood(:));
        end
    end
end

%% 维纳滤波函数
function filtered_img = wiener_filter(img, noise_variance)
    % 在频域进行维纳滤波
    [M, N] = size(img);
    
    % FFT变换
    F = fft2(img);
    
    % 估计信号功率谱密度
    signal_psd = abs(F).^2 / (M * N);
    
    % 维纳滤波器
    H = signal_psd ./ (signal_psd + noise_variance);
    
    % 应用滤波器并逆变换
    filtered_F = F .* H;
    filtered_img = real(ifft2(filtered_F));
end
```

### 4.4 结果分析

不同算法的去噪性能比较：

1. **均值滤波：**
   - 对高斯噪声有一定效果
   - 会使图像产生模糊
   - 计算简单，适合实时应用

2. **中值滤波：**
   - 对椒盐噪声效果极佳
   - 能较好保持边缘信息
   - 非线性滤波，适合脉冲噪声

3. **高斯滤波：**
   - 平滑效果好，噪声抑制能力强
   - 参数调节灵活
   - 会损失一些高频细节

4. **维纳滤波：**
   - 基于统计最优原理
   - 在抑制噪声和保持细节间取得平衡
   - 需要先验知识估计噪声参数

---

## 5. 图像边缘检测和锐化算法

### 5.1 算法原理

**边缘检测算法：**

- **Sobel算子：** 使用3×3卷积核检测边缘
- **Prewitt算子：** 类似Sobel但权重不同
- **Roberts算子：** 2×2对角差分算子
- **Laplacian算子：** 二阶导数边缘检测
- **Canny算子：** 多步骤最优边缘检测

**锐化算法：**

- **拉普拉斯锐化：** 利用二阶导数增强边缘
- **Unsharp Masking：** 原图加上高频成分
- **高通滤波：** 通过高频增强实现锐化

### 5.2 源程序代码

```matlab
%% Sobel边缘检测
function [magnitude, direction] = sobel_edge_detection(img)
    % Sobel算子
    sobel_x = [-1 0 1; -2 0 2; -1 0 1];
    sobel_y = [-1 -2 -1; 0 0 0; 1 2 1];
    
    % 计算梯度
    grad_x = conv2(img, sobel_x, 'same');
    grad_y = conv2(img, sobel_y, 'same');
    
    % 计算幅值和方向
    magnitude = sqrt(grad_x.^2 + grad_y.^2);
    direction = atan2(grad_y, grad_x);
end

%% Canny边缘检测
function edge_img = canny_edge_detection(img, low_thresh, high_thresh, sigma)
    % 1. 高斯滤波
    gaussian_kernel = fspecial('gaussian', [5 5], sigma);
    smoothed = conv2(img, gaussian_kernel, 'same');
    
    % 2. 计算梯度
    [grad_mag, grad_dir] = sobel_edge_detection(smoothed);
    
    % 3. 非极大值抑制
    suppressed = non_maximum_suppression(grad_mag, grad_dir);
    
    % 4. 双阈值检测和边缘连接
    edge_img = double_threshold_linking(suppressed, low_thresh, high_thresh);
end

%% Unsharp Masking锐化
function sharpened = unsharp_masking(img, amount, sigma)
    % 创建模糊版本
    gaussian_kernel = fspecial('gaussian', [5 5], sigma);
    blurred = conv2(img, gaussian_kernel, 'same');
    
    % Unsharp mask
    mask = img - blurred;
    sharpened = img + amount * mask;
    sharpened = max(0, min(255, sharpened));
end
```

### 5.3 结果分析

1. **边缘检测算法比较：**
   - **Sobel算子：** 检测效果好，能提供梯度方向信息
   - **Prewitt算子：** 与Sobel类似，边缘定位精度略低
   - **Roberts算子：** 对噪声敏感，边缘较粗
   - **Laplacian算子：** 对噪声很敏感，需预滤波
   - **Canny算子：** 检测精度最高，边缘连续性好

2. **锐化算法比较：**
   - **拉普拉斯锐化：** 增强效果明显，可能放大噪声
   - **Unsharp Masking：** 效果自然，参数可调
   - **高通滤波：** 增强高频成分，锐化效果显著

---

## 总结

本报告成功实现了5个重要的数字图像处理算法：

1. **图像几何变换：** 实现了缩放、旋转、平移等基本几何操作
2. **直方图处理：** 通过均衡化和规定化改善图像对比度
3. **频域变换：** 掌握了2D DFT的原理和实现方法
4. **图像去噪：** 比较了多种去噪算法的效果
5. **边缘检测和锐化：** 实现了多种经典的边缘检测和锐化算法

### 主要收获

1. **理论与实践结合：** 通过编程实现加深了对算法原理的理解
2. **算法性能分析：** 学会了使用定量指标评价算法效果
3. **参数调优经验：** 掌握了不同算法参数对结果的影响

### 改进方向

1. 可以进一步优化算法的计算效率
2. 增加更多的性能评价指标
3. 实现算法的实时处理能力

通过本次实验，全面掌握了数字图像处理的基本技术和方法，为后续的深入学习打下了坚实基础。

---

## 参考文献

1. Gonzalez R C, Woods R E. Digital Image Processing[M]. 4th ed. Pearson, 2018.
2. 张德丰. 数字图像处理—MATLAB版[M]. 清华大学出版社, 2020.
3. Pratt W K. Digital Image Processing[M]. 4th ed. Wiley, 2007.
